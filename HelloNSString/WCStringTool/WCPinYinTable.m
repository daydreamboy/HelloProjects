//
//  WCPinYinTable.m
//  HelloNSString
//
//  Auto generated by generate_objc_dict.rb on 2020-08-05 23:37:33 +0800.
//  !!! Don't modify it manually
//  Copyright Â© 2020 wesley_chen. All rights reserved.
//

#import "WCPinYinTable.h"
#import <QuartzCore/QuartzCore.h>

static dispatch_queue_t sQueue;

@implementation WCPinYinInfo
@end

@interface WCPinYinTable ()
@property (nonatomic, strong) NSMutableDictionary<NSNumber *, WCPinYinInfo *> *unicode2PinYinStorage;
@property (nonatomic, assign, readwrite) NSTimeInterval loadTimeInterval;
@end

@implementation WCPinYinTable

+ (instancetype)sharedInstance {
    static dispatch_once_t sOnceToken;
    static WCPinYinTable *sInstance;
    
    dispatch_once(&sOnceToken, ^{
        if (!sQueue) {
            sQueue = dispatch_queue_create("com.wc.WCPinYinTable", DISPATCH_QUEUE_SERIAL);
        }
        
        sInstance = [[WCPinYinTable alloc] init];
        sInstance.unicode2PinYinStorage = [NSMutableDictionary dictionary];
    });
    
    return sInstance;
}

- (void)preloadWithFilePath:(NSString *)filePath completion:(void (^)(BOOL success))completion async:(BOOL)async {
    dispatch_block_t taskBlock = ^{
        NSTimeInterval timeStart = CACurrentMediaTime();
        BOOL isDirectory = NO;
        BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&isDirectory];
        if (fileExists && !isDirectory) {
            NSError *error;
            NSString *content = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:&error];
            if (error || content.length == 0) {
                self.loadTimeInterval = CACurrentMediaTime() - timeStart;
                !completion ?: completion(NO);
            }
            else {
                NSArray<NSString *> *lines = [content componentsSeparatedByString:@"\n"];
                __block NSMutableDictionary *tempMap = [NSMutableDictionary dictionaryWithCapacity:lines.count];
                @autoreleasepool {
                    [lines enumerateObjectsUsingBlock:^(NSString * _Nonnull line, NSUInteger idx, BOOL * _Nonnull stop) {
                        NSMutableArray *lineComponents = [[line componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] mutableCopy];
                        [lineComponents removeObject:@""];
                        
                        if (lineComponents.count > 1) {
                            NSString *unicodeString = lineComponents[0];
                            if (unicodeString.length == 4) {
                                // @see https://stackoverflow.com/a/3648562
                                unsigned unicode = 0;
                                NSScanner *scanner = [NSScanner scannerWithString:unicodeString];
                                [scanner scanHexInt:&unicode];
                                
                                if (unicode) {
                                    WCPinYinInfo *info = [[self class] createPinYinInfoWithUnicode:unicode unicodeString:unicodeString pinYinInfoString:lineComponents[1]];
                                    
                                    NSMutableArray<WCPinYinInfo *> *tempAlternatives = [NSMutableArray arrayWithCapacity:lineComponents.count];
                                    for (NSInteger i = 2; i < lineComponents.count; ++i) {
                                        WCPinYinInfo *alternative = [[self class] createPinYinInfoWithUnicode:unicode unicodeString:unicodeString pinYinInfoString:lineComponents[i]];
                                        [tempAlternatives addObject:alternative];
                                    }
                                    
                                    info.alternatives = tempAlternatives;
                                    
                                    tempMap[@(info.unicode)] = info;
                                }
                            }
                        }
                    }];
                }
                
                self.unicode2PinYinStorage = tempMap;
                
                self.loadTimeInterval = CACurrentMediaTime() - timeStart;
                !completion ?: completion(YES);
            }
        }
        else {
            self.loadTimeInterval = CACurrentMediaTime() - timeStart;
            !completion ?: completion(NO);
        }
    };
    
    if (async) {
        dispatch_async(sQueue, ^{
            taskBlock();
        });
    }
    else {
        dispatch_sync(sQueue, ^{
            taskBlock();
        });
    }
}

- (void)cleanup {
    dispatch_sync(sQueue, ^{
        [[WCPinYinTable sharedInstance].unicode2PinYinStorage removeAllObjects];
    });
}

- (nullable WCPinYinInfo *)pinYinInfoWithTextCharacter:(NSString *)textCharacter {
    if (![textCharacter isKindOfClass:[NSString class]] || textCharacter.length != 1) {
        return nil;
    }
    
    __block NSNumber *unicode;
    
    [textCharacter enumerateSubstringsInRange:NSMakeRange(0, textCharacter.length) options:NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
        
        NSUInteger lengthByUnichar = [substring length];
        
        if (lengthByUnichar == 1) {
            unichar buffer[2] = {0};
            
            [substring getBytes:buffer maxLength:sizeof(unichar) usedLength:NULL encoding:NSUTF16StringEncoding options:0 range:NSMakeRange(0, substring.length) remainingRange:NULL];
            
            unicode = [NSNumber numberWithUnsignedShort:buffer[0]];
        }
        else if (lengthByUnichar == 2) {
            unsigned int buffer[2] = {0};
            
            [substring getBytes:buffer maxLength:sizeof(unsigned int) usedLength:NULL encoding:NSUTF32StringEncoding options:0 range:NSMakeRange(0, substring.length) remainingRange:NULL];
            
            unicode = [NSNumber numberWithUnsignedInt:buffer[0]];
        }
    }];
    
    if (!unicode) {
        return nil;
    }
    
    return self.unicode2PinYinStorage[unicode];
}

#pragma mark -

+ (WCPinYinInfo *)createPinYinInfoWithUnicode:(unsigned)unicode unicodeString:(NSString *)unicodeString pinYinInfoString:(NSString *)pinYinInfoString {
    NSString *pinYin = [[pinYinInfoString componentsSeparatedByCharactersInSet:[[NSCharacterSet letterCharacterSet] invertedSet]] componentsJoinedByString:@""];
    NSString *tone = [[pinYinInfoString componentsSeparatedByCharactersInSet:[[NSCharacterSet decimalDigitCharacterSet] invertedSet]] componentsJoinedByString:@""];
    
    WCPinYinInfo *info = [WCPinYinInfo new];
    info.text = [NSString stringWithFormat:@"%C", (unichar)unicode];
    info.unicode = unicode;
    info.unicodeString = [NSString stringWithFormat:@"0x%@", unicodeString];
    info.pinYin = pinYin;
    info.tone = [tone integerValue];
    info.pinYinWithTone = @"";
    info.firstLetter = [pinYin substringToIndex:1];
    info.firstSyllable = ({
        NSString *firstSyllable = [pinYin substringToIndex:1];
        
        if ([pinYin hasPrefix:@"zh"] || [pinYin hasPrefix:@"ch"] || [pinYin hasPrefix:@"sh"]) {
            firstSyllable = [pinYin substringToIndex:2];
        }
        
        firstSyllable;
    });
    
    return info;
}

@end
